#pynmsg
======

This is `pynmsg`, a Python extension module implemented in
[Cython](http://cython.org/) for the [nmsg](https://github.com/farsightsec/nmsg)
C library, `libnmsg`. If you want to shuffle NMSG datagrams to and fro using 
Python, this is the right place. 

##Building
--------
Building from a git checkout requires a C compiler, Python (including the Python developer package), Cython, and the `nmsg` library to be installed first.
Distribution tarballs ship with a copy of the Cython-generated code and do not
require Cython to actually be installed.

`pynmsg` is built by running `setup.py`:

    python setup.py build

##Testing
-------

To get you started, here's a short example of building and sending an ipconn 
NMSG datagram. In one terminal load up a python interpreter and enter the 
following:
```python
>>>import nmsg
>>>import sys
>>>i = nmsg.input.open_sock("127.0.0.1", 9430)
>>>while True:
>>>    m = i.read()
>>>    if not m:
>>>        break
>>>    nmsg.print_nmsg_header(m, sys.stdout)
>>>    for key in m.keys():
>>>        val = m[key]
>>>        print "{0}: {1}".format(key, repr(val))

```
You've just instantiated an NMSG input object that will listen at 127.0.0.1/9430
for NMSGS and print the header and some contents.

In another terminal, load up another interpreter and type this:
```Python
>>> import nmsg
>>> import time
>>> import socket
>>> o = nmsg.output.open_sock("127.0.0.1", 9430)
>>> o.set_buffered(False)
>>> m = nmsg.msgtype.base.ipconn()
>>> t = time.time()
>>> m.time_sec = int(t)
>>> m.time_nsec = int((t - int(t)) * 1E9)
>>> m['srcip'] = socket.gethostbyname(socket.gethostname())
>>> m['dstip'] = socket.gethostbyname(socket.gethostname())
>>> m['srcport'] = 2134
>>> m['dstport'] = 80
>>> m['proto'] = socket.getprotobyname("TCP")
>>> o.write(m)
```
You just built and injected a single ipconn NMSG. In your first interpreter 
session, you should see something akin to:
```
[2014-05-24 15:35:49.738719940] [1:5 base ipconn] [] [] [] 
srcip: '10.0.1.40'
dstip: '10.0.1.40'
srcport: 2134L
dstport: 80L
proto: 6L

```
Congratulations! You've just written and received your first NMSG datagram
using `pynmsg`. Let's explore further...

##API Reference
-------------
NYI

##Example Tools Reference
-----------------------
Included with `pynmsg` are a suite of small functional tools to demonstrate the
utility of `nmsg` extended into Python.

###nmsg_message.py
---------------
First and foremost, it'd be nice to build and send a few NMSG datagrams. Using
`nmsg_message.py` you can do just that. It builds and sends ipconn 
(IP connection) typed NMSG datagrams filled with bogus data. Ipconn messages
(like the one we sent in the example above) are 5-tuples intended to hold 
stateless information about IP connections. Helpful documentation on NMSG data 
types can  be found 
[here](https://archive.farsightsecurity.com/NMSG_Data_Types/).
By default the programs sends NMSGs to 127.0.0.1/9430, but this can overridden.

```
$ ./nmsg_message.py -h
usage: nmsg_message.py [-h] [-n NUMBER] [addr_port]

simple NMSG ipconn client

positional arguments:
  addr_port             address/port to listen for incoming NMSG datagrams

optional arguments:
  -h, --help            show this help message and exit
  -i NUMBER, --number NUMBER
                        number of NMSG datagrams to send
```
It is invoked as per the following:
```
$ ./nmsg_message.py -n2 127.0.0.1/9431
sending 2 ipconn NMSG datagrams to 127.0.0.1/9431...
```
Using `nmsgtool` (instantiated prior to sending), we can capture and display 
the results:

```
$ nmsgtool -l 127.0.0.1/9431 -o -
[18] [2014-05-22 00:51:35.526690006] [1:5 base ipconn] [00000000] [] [] 
srcip: 127.0.0.0
srcport: 0
dstip: 127.1.0.0
dstport: 65535

[18] [2014-05-22 00:51:35.526719093] [1:5 base ipconn] [00000000] [] [] 
srcip: 127.0.0.1
srcport: 1
dstip: 127.1.0.1
dstport: 65534
```

###nmsg_sock_dump.py
-----------------
Ok, that was fun, but you probably want to write your own Python program to 
capture and display some NMSG datagrams. Check out `nmsg_sock_dump.py`. It 
listens for incoming NMSG datagrams using the network socket interface and
decodes and dumps them to the screen. By default it listens for NMSGs on 
127.0.0.1/9430, but this can overridden.

```
$ ./nmsg_sock_dump.py -h
usage: nmsg_sock_dump.py [-h] [addr_port]

listen for NMSG datagrams and dump them to the screen

positional arguments:
  addr_port   address/port to listen for incoming NMSG datagrams

optional arguments:
  -h, --help  show this help message and exit
```
Using `nmsg_message.py` from above we can fire off a sample NMSG datagram and 
then capture and display it using `nmsg_sock_dump.py`:
```
$ ./nmsg_message.py -n1
sending 1 ipconn NMSG datagrams to 127.0.0.1/9430...
```

```
$ ./nmsg_sock_dump.py
listening for NMSG datagrams on 127.0.0.1/9430...
[2014-05-22 16:01:59.212557077] [1:5 base ipconn] [] [] [] 
srcip: '127.0.0.0'
dstip: '127.1.0.0'
srcport: 0L
dstport: 65535L
```
###nmsg_cat.py
-----------
What if you need to redirect a flow of NMSG datagrams from one place to 
another? `nmsg_cat.py` is a simple tool to do that. You can think of it as a 
cat-like redirector for NMSG. By default, `nmsg_cat.py` uses 127.0.0.1/8430 to 
listen for input and 127.0.0.1/9430 to send its output. These can be overridden
at the command line.
```
$ ./nmsg_cat.py -h
usage: nmsg_cat.py [-h] [-i INPUT] [-o OUTPUT]

redirect NMSG datagrams

optional arguments:
  -h, --help            show this help message and exit
  -i INPUT, --input INPUT
                        address/port to receive incoming NMSG datagrams
  -o OUTPUT, --output OUTPUT
                        address/port to fire outgoing NMSG datagrams
```
The program prints to stderr a `.` for every 1,000 datagrams it forwards and 
for every 10,000, the actual number.


A sample invocation, assuming an NMSG producer is sending datagrams to 
127.0.0.1/8431 and something is listening for them at 127.0.0.1/9431:
```shell
$ ./nmsg_cat.py -i127.0.0.1/8431 -o127.0.0.1/9431
redirecting NMSGS: 127.0.0.1/8431-->127.0.0.1/9431
..........10000..........20000..........30000..........40000...
```

###nmsg_file_dump.py
-----------------
If you want to dump the contents of a previously created NMSG file, 
`nmsg_file_dump.py` is your avatar.

```
$ ./nmsg_file_dump.py -h
usage: nmsg_file_dump.py [-h] infile

dump the contents of an NMSG file

positional arguments:
  infile      file containing NMSG datagrams

optional arguments:
  -h, --help  show this help message and exit
```
Again we can leverage `nmsgtool`, this time to capture two NMSG datagrams from 
SIE channel 80 (Conficker Sinkhole) and spit them out to a file.
```
$ nmsgtool -C ch80 -c 2 -w ch80-2pack.nmsg
```
We can use `nmsg_file_dump.py` to dump these (IPs and hostnames redacted):
```
$ ./nmsg_file_dump.py ch80-2pack.nmsg 
[2014-05-22 15:16:39.935642536] [1:4 base http] [1a1a1a1a] [FSI] [trafficconverter] 
dstip: 'xx.xx.xx.xx'
request: 'GET / HTTP/1.1\r\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727)\r\nHost: foo.bar\r\nPragma: no-cache\r\nVia: 1.0 ARJUJGSM1CB01:800 (squid/2.7.STABLE9), 1.0 internal\r\nX-Forwarded-For: xx.xx.xx.xx\r\nCache-Control: max-age=259200\r\nConnection: keep-alive\r\n\r\n'
srcport: 19614L
srcip: 'xx.xx.xx.xx'
dstport: 80L
type: 'sinkhole'

[2014-05-22 15:16:39.935661407] [1:4 base http] [1a1a1a1a] [FSI] [trafficconverter] 
dstip: 'xx.xx.xx.xx'
request: 'GET / HTTP/1.0\r\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\r\nHost: foo.bar\r\nPragma: no-cache\r\n\r\n'
srcport: 1949L
srcip: 'xx.xx.xx.xx'
dstport: 80L
type: 'sinkhole'
```

###nmsg_channel_dump.py
--------------------
If you want to dump the NMSG datagrams flying around across a live channel 
(assuming you have the proper access) `nmsg_channel_dump.py` is your
champion.
```
foo
```

```
foo
```

###nmsg_encode_hello_client.py
---------------------------
Let's check out some sample programs that build slightly more complex NMSG
datagrams. The `nmsg_encode_hello_client.py` program builds NMSGs of type 
`encode`. The encode message type is a simple format for enabling the 
serialiazation of data into a handful of popular formats:

 - [JSON](http://www.json.org/)
 - [YAML](http://www.yaml.org/)
 - [MsgPack](http://msgpack.org/)
 - [XML](http://www.xml.org)

And:

 - Text

`nmsg_encode_hello_client.py` serializes a text blob using one or more of the
above encodings, sticks in an NMSG datagram, and fires one or more of them off.
```
$ ./nmsg_encode_hello_client.py -h
usage: nmsg_encode_hello_client.py [-h] [-i ITERATIONS]
                                   [-t {TEXT,JSON,YAML,MSGPACK,XML,ALL}]
                                   [addr_port]

simple NMSG encode client

positional arguments:
  addr_port             address/port to listen for incoming NMSG datagrams

optional arguments:
  -h, --help            show this help message and exit
  -i ITERATIONS, --iterations ITERATIONS
                        number of iterations to send
  -t {TEXT,JSON,YAML,MSGPACK,XML,ALL}, --type {TEXT,JSON,YAML,MSGPACK,XML,ALL}
                        NSMG datagram(s) to send, use 'ALL' to send all types
```
To send two of each type, we would invoke the program as per the following:
```
$ ./nmsg_encode_hello_client.py -tALL -i2 127.0.0.1/8431
sending NMSG datagrams to 127.0.0.1/8431
sent 2 TEXT-encoded payloads
sent 2 JSON-encoded payloads
sent 2 YAML-encoded payloads
sent 2 MSGPACK-encoded payloads
sent 2 dummy XML-encoded payloads
```
And as it turns out, we also have a mate for `nmsg_encode_hello_client.py` that
will happily receive, decode, and print its NMSG datagrams...

###nmsg_encode_hello_server.py
---------------------------
The server component to `nmsg_encode_hello_client.py`, 
`nmsg_encode_hello_server.py` listens for encode type NMSG datagrams and 
decodes and prints the results. Other NMSG datagrams are silently dropped.

By default, it listens on 127.0.0.1/9430, but this can be overridden. 
For every NMSG datagram it receives it prints to stderr the header info followed
by a decoded payload (or error message). JSON encoded payloads are
pretty-printed.

```
$ ./nmsg_encode_hello_server.py -h
usage: nmsg_encode_hello_server.py [-h] [addr_port]

Simple NMSG encoding server

positional arguments:
  addr_port          address/port to listen for incoming NMSG datagrams

optional arguments:
  -h, --help         show this help message and exit
```
Sample output is below:
```
$ ./nmsg_encode_hello_server.py 
listening on 127.0.0.1/9430
[2014-05-22 19:51:58.290600061] [1:11 base encode] [] [] [] 
type: JSON
payload: {
    "foo": "bar", 
    "hello": "world", 
    "id": 0
}

[2014-05-22 19:51:58.290648937] [1:11 base encode] [] [] [] 
type: JSON
payload: {
    "foo": "bar", 
    "hello": "world", 
    "id": 1
}
```

###nmsg_nonblocking.py
-------------------
If you want to build a synchronous server that consumes NMSG datagrams you
can use Python's [polling](https://docs.python.org/2/library/select.html#polling-objects) interface with `pynmsg`. `nmsg_nonblocking.py` is an example of
how to do that. It registers the file descriptor from a `pynmsg` socket input 
object with a polling object and times out (by default) every 1000 
milliseconds while waiting for NMSGS. Like all of the other network programs 
here, by default, it listens on 127.0.0.1/9430, but this can be overridden.
```
$ ./nmsg_nonblocking.py -h
usage: nmsg_nonblocking.py [-h] [-t TIMEOUT] [addr_port]

Asynchronous IO polling example

positional arguments:
  addr_port             address/port to listen for incoming NMSG datagrams

optional arguments:
  -h, --help            show this help message and exit
  -t TIMEOUT, --timeout TIMEOUT
                        millisecond timeout
```
For example:
```
$ ./nmsg_nonblocking.py
Nope, no NMSG...
Nope, no NMSG...
Nope, no NMSG...
Nope, no NMSG...
Nope, no NMSG...
```
And then in another terminal fire up the `nmsg_message.py` as per the
following:
```
$ ./nmsg_message.py -n1
sending 1 ipconn NMSG datagrams to 127.0.0.1/9430...
$ ./nmsg_message.py -n2
sending 2 ipconn NMSG datagrams to 127.0.0.1/9430...
```
And you should see:
```
[2014-05-24 15:09:49.325844049] [1:5 base ipconn] [] [] [] 
Nope, no NMSG...
Nope, no NMSG...
Nope, no NMSG...
[2014-05-24 15:09:52.647264003] [1:5 base ipconn] [] [] [] 
[2014-05-24 15:09:52.647317886] [1:5 base ipconn] [] [] [] 
Nope, no NMSG...
```

###nmsg_io_callback.py
-------------------
`libnmsg` provides an event-based callback interface, similar to 
[`libpcap`](http://www.tcpdump.org/pcap.html). That is, upon receiving an NMSG
datagram, a user-specified function will be called to act upon it.
`nmsg_io_callback.py` accesses that functionality using `pynmsg`'s io API. It
expects a filename argument and it simply counts each NMSG it finds.
```
$ ./nmsg_io_callback.py -h
usage: nmsg_io_callback.py [-h] infile

open an NMSG file and execute a callback function on each message

positional arguments:
  infile      file containing NMSG datagrams

optional arguments:
  -h, --help  show this help message and exit
```
We can run the programm to count up the number of NMSGS in a file containing
some raw passive DNS NMSGs from Farsight's massive sensor network:
```
$ ./nmsg_io_callback.py ch202.nmsg 
....................
count: 200058
```
We can check to make sure it's correct using `nmsgtool`:
```
$ nmsgtool -r ch202.nmsg | grep "1:9 base dnsqr" | wc -l
200058
```
License
-------

Copyright (C) 2009-2014 Farsight Security, Inc., Licensed under the [Apache License, Version 2.0][license].

[license]: http://www.apache.org/licenses/LICENSE-2.0
